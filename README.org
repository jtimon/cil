
* Compiled Interpreted Language

Cil is a general purpose experimental language that is meant to be
interpreted or compiled to machine code or to some other high level
language.

The goal is to have a self hosted implementation as soon as possible,
although the bootstrap implementation is written in rust.

* Dependencies

Only rustc, and it's temporary.
Next, when self hosted, nasm will be the only dependency.
Then some more advanced compiler backend like LLVM. MLIR, QBM or Tilde can be used.
Or perhaps just translate to a higher language first.

* Get started

See /examples directory after reading this file.
It can be run with cargo for convenience, but it's not needed to since
it has no dependencies besides rustc, rustc can be used directly instead.

To build using cargo:

#+BEGIN_SRC bash
cargo build
#+END_SRC

To run an example using cargo:

#+BEGIN_SRC bash
cargo run examples/demo.cil
#+END_SRC

* WARNING: Do not use this language, it is not ready.

This is just a pet experimental language. Nobody should use it for
anything besides testing or extending it.
It may never be finished. The name may change in the future too.
It may become unmaintained.

* Pure functions:

So called "pure functional languages" do not use only pure functions,
they all use procedures too, for side effects. At the same time,
procedural languages can have pure functions too.
Pure functions could be declared explicitly and the compiler could make
sure that they are in fact pure functions.

This language has different reserved words for declaring different
types of "callables".

** func

Pure functions (funcs) don't have "side effects".
In other words, [[https://en.wikipedia.org/wiki/Memoization][memoization]] is possible for funcs.

** proc

Procedures (procs) can have side effects. Procs can call funcs, but not the
other way around.
In other words, memoization may not be possible because the result may be different
each time or, even if it was the same, some side effects may not be
executed if memoization was used instead of executing the procedure again.

** macro

Macros are used for metaprogramming. They are executed at compile time.
Macros can call funcs or procs and vice-versa

* Modes:

Somewhat similar to [[https://www.roc-lang.org/platforms][roclang's platforms]], but they can be used per file rather
than per executable, to impose special restrictions per file, as per
the chosen mode.
For example, there can be a "mode pure" that only allows pure
functions to be defined in the file, but no procedures.
Users should be able to define their own modes with their own extra
restrictions and their own built-in types and core functions or
procedures.
A user could define a mode not allowing calls to core procedure
"print", or replacing it with his own version, for example.

Here are some "built-in" modes:

** script

Basically no restrictions, statements will just be run as they are,
including if, switch or while statements in the root context of the
file, for example.

** TODO safe_script

Similar to script, but any unsafe action like running a non
whitelisted command or reading or writing to the file system will
require confirmation from the user running the script.
In other words, it's like script, but with internal wrappers around
certain things

This idea comes from Roc, but as far as I know Roc hasn't implemented it yet.
Not implemented yet.

** cli

It only allows declarations in the root context of the file.
It requires the declaration of a proc named "main", which will be run.

** test

Similar to script, but it only allows declarations and calls in the root context.
It does not allow mut declarations in the root context (this may change).

** lib

Only allow constant declarations, not mut declarations.
Currently it is useless, because "import" is not implemented yet.

** TODO pure

Like lib, but it doesn't allow proc declarations, calls or imports.
When a mode pure file is imported, one can be sure that everything exposed
by the file are constants or pure functions.
Not implemented yet.

The subset of this language that's allowed in mode pure is a truly
purely functional language, more pure than lisp, clojure, haskell or
erlang; in the "pure functions only" sense.

** TODO external

Similar to lib, but to interface with other languages.
Files of this mode should only contain declarations of headers, basically.
Not implemented yet.
