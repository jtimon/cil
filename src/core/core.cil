mode lib

eq     := ext_func(a: I64, b: I64) returns Bool;
lt     := ext_func(a: I64, b: I64) returns Bool;
lteq   := ext_func(a: I64, b: I64) returns Bool;
gt     := ext_func(a: I64, b: I64) returns Bool;
gteq   := ext_func(a: I64, b: I64) returns Bool;

add := ext_func(a: I64, b: I64) returns I64;
sub := ext_func(a: I64, b: I64) returns I64;
mul := ext_func(a: I64, b: I64) returns I64;
div := ext_func(a: I64, b: I64) returns I64;

itoa := ext_func(a: I64) returns String;
atoi := ext_func(a: String) returns I64;

str_eq := ext_func(a: String, b: String) returns Bool;
concat := ext_func(a: String, b: String) returns String;
str_len := ext_func(a: String) returns I64;
str_get_substr := ext_func(a: String, start: I64, end: I64) returns String;

print   := ext_proc(args: ..String); // TODO move 'print' to std after supporting variadic arguments
// TODO self host using print once the self escaped '\n' bug is fixed
println := ext_proc(args: ..String); // TODO move 'println' to std after fixing
// TODO implement the variadic part of print/println in std
single_print := ext_proc(a: String); // TODO

exit    := ext_proc(code: I64);
// TODO parse with dots like other languages, then change the direction of the slash depending on the os
// TODO use imports in declarations:
// example_cil: my_matrix_def := import(matrix.matrix_def)
// example_cil: my_matrix : struct = import(matrix)
// example_python: from matrix import matrix_def as my_matrix_def
import  := ext_proc(path: String);
runfile := ext_proc(args: ..String);

eval_to_str     := ext_proc(a: String) returns String;
eval_to_ast_str := ext_proc(src: String) returns String; // TODO
eval_to_expr := ext_proc(src: String) returns Expr; // TODO

input_read_line := ext_proc(a: String) returns String;

readfile := ext_proc(path: String) returns String;
writefile := ext_proc(path: String, contents: String) returns String; // TODO

xor := func(a: Bool, b: Bool) returns Bool {
    // return a.and(not(b)).or(b.and(not(a))) // TODO implement UFCS (Uniform Function Call Syntax) for funccall return values
    // return or(a.and(not(b)), b.and(not(a))) // TODO implement UFCS (Uniform Function Call Syntax) again in self hostinf
    return or(and(a, not(b)), and(b, not(a)))
}

// TODO fix arg names colliding when functions call other functions
not := func(not_arg: Bool) returns Bool {
    if not_arg {
        return false
    }
    return true
}

// TODO variadic arguments should allowed 0 arguments too, unlike in print, println, and, or
// TODO implement the variadic versions of and/or
or := func(arg_or_a: Bool, arg_or_b: Bool) returns Bool {
    if arg_or_a {
        return true
    }
    if arg_or_b {
        return true
    }
    return false
}

and := func(arg_and_a: Bool, arg_and_b: Bool) returns Bool {
    if not(arg_and_a) {
        return false
    }
    if not(arg_and_b) {
        return false
    }
    return true
}

// Note that Bool, I64 and String don't have fields because the're the core types
// think of them as "half-external types" for now
Bool := struct {
    to_str := func(self: Bool) returns String {
        if self {
            return "true"
        }
        return "false"
    }

    // necessary for branchless arithmetics (but it must be implemented as a cast for it to make sense that way)
    to_int := func(self: Bool) returns I64 {
        if self {
            return 1
        }
        return 0
    }
}

I64 := struct {
    // mut data : I64 = 0 // self host the data

    to_str := func(self: I64) returns String {
        return itoa(self)
    }

    // TODO implement operators and allow operator overload
    __add__ := func(self: I64, other: I64) returns I64 {
        return add(self.data, other.data)
    }
}

String := struct {
    to_int := func(self: String) returns I64 {
        return atoi(self)
    }
}

// TODO rustic interfaces with arrays, for variadic functions at least at first
# array_Bool_len := ext_func(a: ArrayBool) returns I64;
# array_Bool_get := ext_func(a: ArrayBool, pos: I64) returns Bool;

# array_i64_len := ext_func(a: ArrayI64) returns I64;
# array_i64_get := ext_func(a: ArrayI64, pos: I64) returns I64;

# array_str_len := ext_func(a: ArrayString) returns I64;
# array_str_get := ext_func(a: ArrayString, pos: I64) returns String;

// TODO implement macros:
// array_struct_len := ext_func(a: ArrayStruct) returns I64;
// array_str_get := ext_func(a: ArrayStruct, pos: I64) returns String;
// array_generic_len := ext_func(a: Array) returns I64;
// array_generic_get := ext_func(a: Array, pos: I64) returns String;
