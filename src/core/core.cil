mode lib

import("src/core/constants")

// Comparisons are hateful, plus two of them are probably enough for now:
lt        := ext_func(a: I64, b: I64) returns Bool;
gt        := ext_func(a: I64, b: I64) returns Bool;

// Minimal arithmehics are fair and necessary
add       := ext_func(a: I64, b: I64) returns I64;
sub       := ext_func(a: I64, b: I64) returns I64;
mul       := ext_func(a: I64, b: I64) returns I64;
div       := ext_func(a: I64, b: I64) returns I64;
mod       := ext_func(a: I64, b: I64) returns I64; // TODO implement 'mod'

concat    := ext_func(a: String, b: String) returns String; // TODO self host once we have pointers, mem alloc and free simulated

// TODO implement the variadic part of print/println in std
print   := ext_proc(args: ..String); // TODO move 'print' to std after supporting variadic arguments
// TODO now that '\n' bug is fixed, we're waiting for user variadic arguments
println := ext_proc(args: ..String); // TODO move 'println' to std after fixing
// TODO This should be ext, and the print and println self hosted
single_print := proc(s: String) {
    print(s) // TODO use some lowe level thing so tha print can depend on this instead of the other way around
}

exit    := ext_proc(code: I64);
// TODO parse with dots like other languages, then change the direction of the slash depending on the os
// TODO use imports in declarations:
// example_cil: my_matrix_def := import(matrix.matrix_def)
// example_cil: my_matrix : struct = import(matrix)
// example_python: from matrix import matrix_def as my_matrix_def
import  := ext_proc(path: String);
runfile := ext_proc(args: ..String);

// Memory allocation

alloc := ext_proc(size: I64) returns I64;
free := ext_proc(ptr: Ptr);

Ptr := struct {
    // TODO meta-program this part after self hosting
    mut ptr_type: String = "Null"
    mut data: I64 = 0
    mut cap: I64 = 0
    mut len: I64 = 0

    new := proc(ptr_type: String) returns Ptr {
        self := Ptr()
        self.ptr_type = ptr_type
        return self
    }

    free := proc(self: Ptr) {
        TODO("Ptr.free not implemented yet")
    }
}

eval_to_str     := ext_proc(a: String) returns String;
eval_to_ast_str := ext_proc(src: String) returns String; // TODO
eval_to_expr := ext_proc(src: String) returns Expr; // TODO

input_read_line := ext_proc(a: String) returns String;

readfile := ext_proc(path: String) returns String;
writefile := ext_proc(path: String, contents: String) returns String; // TODO

not := func(b: Bool) returns Bool {
    if b {
        return false
    }
    return true
}

// TODO variadic arguments should allowed 0 arguments too, unlike in print, println, and, or
// TODO implement the variadic versions of and/or
or := func(a: Bool, b: Bool) returns Bool {
    if a {
        return true
    }
    if b {
        return true
    }
    return false
}

and := func(a: Bool, b: Bool) returns Bool {
    if not(a) {
        return false
    }
    if not(b) {
        return false
    }
    return true
}

// Note that Bool, I64 and String don't have fields because the're the core types
// think of them as "half-external types" for now
Bool := struct {
    size := U8_SIZE

    mut data: I64 = 0

    len := func(self: Bool) returns I64 {
        return 1
    }

    eq := func(a: Bool, b: Bool) returns Bool {
        return or(and(a, b), and(not(b), not(a)))
    }

    to_str := func(self: Bool) returns String {
        if self {
            return "true"
        }
        return "false"
    }

    // necessary for branchless arithmetics (but it must be implemented as a cast for it to make sense that way)
    to_int := func(self: Bool) returns I64 {
        // TODO move to directly return self.data instead
        if self {
            return 1
        }
        return 0
    }

    from_i64 := func(i: I64) returns Bool {
        if gt(i, 0) {
            return true
        }
        return false
    }
}

lteq := func(a: I64, b: I64) returns Bool {
    if lt(a, b) {
        return true
    }
    if I64.eq(a, b) {
        return true
    }
    return false
}

gteq := func(a: I64, b: I64) returns Bool {
    if gt(a, b) {
        return true
    }
    if I64.eq(a, b) {
        return true
    }
    return false
}

// TODO support U8
U8 := struct {
    size: I64 = U8_SIZE

    // TODO FIX can't use itself as base data, can it?
    // TODO This is the base of data storage, not I64
    // mut data: I8 = 0

    len := func(self: I64) returns I64 {
        return 1
    }

    to_i64 := func(self: U8) returns I64 {
        return cast("I64", self) // TODO implement cast, start easy with U8 to I64
    }

    from_i64 := func(i: I64) returns U8 {
        if lt(0, i) {
            return error("Negative values cannot be cast into '", "U8", "'")
        }
        if gt(i, MAX_U8) {
            return error("U8", "canot be casted from a number greater than ", I64.to_str(MAX_U8), "'")
        }
        TODO("i64_to_u8 not implemented yet")
        return 0
    }
}

I64 := struct {
    size: I64 = I64_SIZE
    // mut data := 0 // TODO Use [8]U8 for this one

    len := func(self: I64) returns I64 { return 1 }

    eq := func(a: I64, b: I64) returns Bool {
        if or(gt(a, b), gt(b, a)) {
            return false
        }
        if or(lt(a, b), lt(b, a)) {
            return false
        }
        return true
    }

    to_str := func(self: I64) returns String {
        itoa := ext_func(a: I64) returns String;
        return itoa(self)
    }

    from_str := func(str: String) returns I64 {
        atoi := ext_func(a: String) returns I64;
        return atoi(str) // TODO: this can fail and panic from rust
    }

    // TODO: implement operators and allow operator overload
    __add__ := func(self: I64, other: I64) returns I64 {
        return add(self, other)
    }
}

String := struct {
    // TODO get rid of special cases for String besides literals
    // mut ptr : Ptr = Ptr()
    mut ptr : I64 = 0
    mut cap : I64 = 0

    size := func(self: String) {
        panic("Size of strings can't always be known at compile time, certainly not at struct declaration time.\nSuggestion: Try len() instead")
    }

    len := func(self: String) returns I64 {
        str_len := ext_func(a: String) returns I64;
        return str_len(self)
    }

    eq := func(self: String, other: String) returns Bool {
        str_eq := ext_func(a: String, b: String) returns Bool; // TODO declare only here
        return str_eq(self, other)
    }

    to_int := func(self: String) returns I64 {
        return I64.from_str(self)
    }

    get_substr := func(s: String, start: I64, end: I64) returns String {
        if gt(end, s.len()) {
            panic("get_substr: ", end, " greater than ", s.len())
        }
        str_get_substr := ext_func(s: String, start: I64, end: I64) returns String; // TODO declare only here
        return str_get_substr(s, start, end)
    }

    get_char := func(s: String, pos: I64) returns String {
        start := pos
        end := add(pos, 1)
        return s.get_substr(start, end)
    }
}

// TODO rustic interfaces with arrays, for variadic functions at least at first
# array_Bool_len := ext_func(a: ArrayBool) returns I64;
# array_Bool_get := ext_func(a: ArrayBool, pos: I64) returns Bool;

# array_i64_len := ext_func(a: ArrayI64) returns I64;
# array_i64_get := ext_func(a: ArrayI64, pos: I64) returns I64;

# array_str_len := ext_func(a: ArrayString) returns I64;
# array_str_get := ext_func(a: ArrayString, pos: I64) returns String;

// TODO implement macros:
// array_struct_len := ext_func(a: ArrayStruct) returns I64;
// array_str_get := ext_func(a: ArrayStruct, pos: I64) returns String;
// array_generic_len := ext_func(a: Array) returns I64;
// array_generic_get := ext_func(a: Array, pos: I64) returns String;
