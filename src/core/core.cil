mode lib

not := ext_func(a: bool) returns bool;
and := ext_func(args: ..bool) returns bool;
or  := ext_func(args: ..bool) returns bool;
xor := func(a: bool, b: bool) returns bool {
    // return a.and(not(b)).or(b.and(not(a))) // TODO implement UFCS (Uniform Function Call Syntax) for funccall return values
    return or(a.and(not(b)), b.and(not(a)))
}

eq     := ext_func(a: i64, b: i64) returns bool;
lt     := ext_func(a: i64, b: i64) returns bool;
lteq   := ext_func(a: i64, b: i64) returns bool;
gt     := ext_func(a: i64, b: i64) returns bool;
gteq   := ext_func(a: i64, b: i64) returns bool;

add := ext_func(a: i64, b: i64) returns i64;
sub := ext_func(a: i64, b: i64) returns i64;
mul := ext_func(a: i64, b: i64) returns i64;
div := ext_func(a: i64, b: i64) returns i64;

btoi := ext_func(a: bool) returns i64;
btoa := ext_func(a: bool) returns String;
itoa := ext_func(a: i64) returns String;
atoi := ext_func(a: String) returns i64;

str_eq := ext_func(a: String, b: String) returns bool;
concat := ext_func(a: String, b: String) returns String;
str_len := ext_func(a: String) returns i64;
str_get_substr := ext_func(a: String, start: i64, end: i64) returns String;

exit    := ext_proc(code: i64);
import  := ext_proc(path: String);
runfile := ext_proc(path: String);
print   := ext_proc(args: ..String);
println := ext_proc(args: ..String);

eval_to_str     := ext_proc(a: String) returns String;
input_read_line := ext_proc(a: String) returns String;
