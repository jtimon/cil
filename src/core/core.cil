mode lib

  U8_SIZE := 1
 U16_SIZE := 2
 U32_SIZE := 4
 U64_SIZE := 8
U128_SIZE := 16
U256_SIZE := 32

  I8_SIZE := 1
 I16_SIZE := 2
 I32_SIZE := 4
 I64_SIZE := 8
I128_SIZE := 16
I256_SIZE := 32

// Comparisons are hateful, plus two of them are probably enough for now:
lt        := ext_func(a: I64, b: I64) returns Bool;
gt        := ext_func(a: I64, b: I64) returns Bool;

// Minimal arithmehics are fair and necessary
add       := ext_func(a: I64, b: I64) returns I64;
sub       := ext_func(a: I64, b: I64) returns I64;
mul       := ext_func(a: I64, b: I64) returns I64;
div       := ext_func(a: I64, b: I64) returns I64;
mod       := ext_func(a: I64, b: I64) returns I64; // TODO implement 'mod'

print   := ext_proc(args: ..String); // TODO move 'print' to std after supporting variadic arguments
// TODO self host using print once the self escaped '\n' bug is fixed
println := ext_proc(args: ..String); // TODO move 'println' to std after fixing
// TODO implement the variadic part of print/println in std
single_print := ext_proc(a: String); // TODO

exit    := ext_proc(code: I64);
// TODO parse with dots like other languages, then change the direction of the slash depending on the os
// TODO use imports in declarations:
// example_cil: my_matrix_def := import(matrix.matrix_def)
// example_cil: my_matrix : struct = import(matrix)
// example_python: from matrix import matrix_def as my_matrix_def
import  := ext_proc(path: String);
runfile := ext_proc(args: ..String);

eval_to_str     := ext_proc(a: String) returns String;
eval_to_ast_str := ext_proc(src: String) returns String; // TODO
eval_to_expr := ext_proc(src: String) returns Expr; // TODO

input_read_line := ext_proc(a: String) returns String;

readfile := ext_proc(path: String) returns String;
writefile := ext_proc(path: String, contents: String) returns String; // TODO

xor := func(a: Bool, b: Bool) returns Bool {
    // return a.and(not(b)).or(b.and(not(a))) // TODO implement UFCS (Uniform Function Call Syntax) for funccall return values
    // return or(a.and(not(b)), b.and(not(a))) // TODO implement UFCS (Uniform Function Call Syntax) again in self hostinf
    return or(and(a, not(b)), and(b, not(a)))
}

// TODO fix arg names colliding when functions call other functions
not := func(not_arg: Bool) returns Bool {
    if not_arg {
        return false
    }
    return true
}

// TODO variadic arguments should allowed 0 arguments too, unlike in print, println, and, or
// TODO implement the variadic versions of and/or
or := func(arg_or_a: Bool, arg_or_b: Bool) returns Bool {
    if arg_or_a {
        return true
    }
    if arg_or_b {
        return true
    }
    return false
}

and := func(arg_and_a: Bool, arg_and_b: Bool) returns Bool {
    if not(arg_and_a) {
        return false
    }
    if not(arg_and_b) {
        return false
    }
    return true
}

// Note that Bool, I64 and String don't have fields because the're the core types
// think of them as "half-external types" for now
Bool := struct {
    to_str := func(self: Bool) returns String {
        if self {
            return "true"
        }
        return "false"
    }

    // necessary for branchless arithmetics (but it must be implemented as a cast for it to make sense that way)
    to_int := func(self: Bool) returns I64 {
        if self {
            return 1
        }
        return 0
    }

    from_i64 := func(i: I64) returns Bool {
        if gt(i, 0) {
            return true
        }
        return false
    }

    size := func(self: I64) returns I64 {
        return I64_SIZE
    }
}

i64_eq := func(a: I64, b: I64) returns Bool {
    if or(gt(a, b), gt(b, a)) {
        return false
    }
    if or(lt(a, b), lt(b, a)) {
        return false
    }
    return true
}

lteq := func(a: I64, b: I64) returns Bool {
    if lt(a, b) {
        return true
    }
    if i64_eq(a, b) {
        return true
    }
    return false
}

gteq := func(a: I64, b: I64) returns Bool {
    if gt(a, b) {
        return true
    }
    if i64_eq(a, b) {
        return true
    }
    return false
}

I64 := struct {
    // mut data := 0 // TODO Use [8]U8 for this one

    to_str := func(self: I64) returns String {
        itoa := ext_func(a: I64) returns String;
        return itoa(self)
    }

    from_str := func(str: String) returns I64 {
        atoi := ext_func(a: String) returns I64;
        return atoi(str) // TODO: this can fail and panic from rust
    }

    eq := func(a: I64, b: I64) returns Bool {
        return i64_eq(a, b) // TODO this better
    }

    // TODO: implement operators and allow operator overload
    __add__ := func(self: I64, other: I64) returns I64 {
        return add(self, other)
    }
    
    size := func(self: I64) returns I64 {
        return I64_SIZE
    }
}

String := struct {
    // TODO get rid of special cases for String besides literals
    // mut ptr = 0
    // mut cap = 0

    eq := func(self: String, other: String) returns Bool {
        str_eq := ext_func(a: String, b: String) returns Bool; // TODO declare only here
        return str_eq(self, other)
    }

    len := func(self: String) returns I64 {
        str_len := ext_func(a: String) returns I64;
        return str_len(self)
    }

    to_int := func(self: String) returns I64 {
        return I64.from_str(self)
    }

    get_substr := func(s: String, start: I64, end: I64) returns String {
        if gt(end, s.len()) {
            panic("get_substr: ", end, " greater than ", s.len())
        }
        str_get_substr := ext_func(s: String, start: I64, end: I64) returns String; // TODO declare only here
        return str_get_substr(s, start, end)
    }

    get_char := func(s: String, pos: I64) returns String {
        start := pos
        end := add(pos, 1)
        return s.get_substr(start, end)
    }
}

concat := ext_func(a: String, b: String) returns String;

// TODO rustic interfaces with arrays, for variadic functions at least at first
# array_Bool_len := ext_func(a: ArrayBool) returns I64;
# array_Bool_get := ext_func(a: ArrayBool, pos: I64) returns Bool;

# array_i64_len := ext_func(a: ArrayI64) returns I64;
# array_i64_get := ext_func(a: ArrayI64, pos: I64) returns I64;

# array_str_len := ext_func(a: ArrayString) returns I64;
# array_str_get := ext_func(a: ArrayString, pos: I64) returns String;

// TODO implement macros:
// array_struct_len := ext_func(a: ArrayStruct) returns I64;
// array_str_get := ext_func(a: ArrayStruct, pos: I64) returns String;
// array_generic_len := ext_func(a: Array) returns I64;
// array_generic_get := ext_func(a: Array, pos: I64) returns String;
