mode cli

import("src/core/interpreter")
// interpreter := import("src/core/interpreter") // TODO accept imports as declarations of struct (as namespace)

REPL_PATH: Str = "src/core/modes/repl.cil";

usage := proc() {
    println("Usage: ", LANG_NAME, " [command] [path]\n");
    println("Entering no arguments is equavalent to: '", LANG_NAME, " repl'");
    println("Entering a single argument that's not a command is interpreted as a path, equivalent to: '", LANG_NAME, " interpret <path>'\n");

    println("Commands:\n");

    println("repl: read eval print loop.");
    println("interpret: reads a file in provided <path> and evaluates it.");
    // println("ast: reads a file in provided <path> and prints its abstract syntax tree (aka (lisp-like-syntax ast-from-now-on ) ).");
    println("build: reads a file in provided <path> and compiles it. Not implemented yet.");
    println("run: reads a file in provided <path> and runs it if it compiles. Not implemented yet.");
    println("help: Prints this.\n");
}

// TODO rscil implement arrays
// scan_tokens := func(src: Str) returns Array(Token) {}

// TODO use variadic arguments
// TODO move the repl subcommmand here, rscil only to interpret
main := proc(path: Str) {

    if or(path.eq(""), path.eq("repl")) {
        runfile(REPL_PATH)
        return // TODO fix empty return
    } else {

        if or(
            path.eq("ast"),
            path.eq("interpret"),
            path.eq("build"),
            path.eq("run"),
            path.eq("help"),
            path.eq("-help"),
            path.eq("--help"),
            path.eq("--version"), // REM don't implement this option until it makes sense
            path.eq("-v")
        ) {
            usage()
            return // TODO fix empty return
        } else {
            println("[INFO] '", LANG_NAME, "': Reading file '", path, "'")
            src := readfile(path)
            tokens := scan_tokens(src) // REM don't call scan_tokens from here
            lex_errrors_found := print_lex_errors(tokens, path)
            if gt(lex_errrors_found, 0) {
                println("ERROR: ", lex_errrors_found.to_str(), " lexer errors found.")
            }

            // FIX Lexer.new(path) and we stop callig scan_tokens(src)
            // lexer := Lexer.new(path)
            // lexer.print_lex_errors()
        }
    }
}
