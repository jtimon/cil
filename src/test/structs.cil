mode test

import("src/core/modes/test")

MyStruct := struct {
    static_bool_field: Bool = true
    mut bool_field: Bool = false
    mut int_field: I64 = 0 // 0 is just the default, but you can set something else once in the init func
    // TODO fix type inference in fields
    mut string_field: String = ""

    // TODO allow assingments to struct fields, both mut or only overwrite the default once in init,
    // but then it is no longer "static", that's only for the compiler to care, not the user's problem
    // TODO static vs only_one assignment are details the interpreter should be smart enough to through errors about
    init := func(self: MyStruct, int_const : I64, bool_field : Bool, int_field : I64, string_field) {
        // self.bool_field_static = 69 // TODO think of a keyword to force this to fail
        // self.int_const = 69
        // self.bool_field = true
        // self.int_field = 1
        // self.string_field = "true"
    }
    new := func(bool_field: Bool, int_field: I64, string_field: String) returns MyStruct {
        self := MyStruct()
        self.bool_field = bool_field
        self.int_field = int_field
        self.string_field = string_field
        return self
    }

    to_string := proc(self: MyStruct) returns String {
        todo("implement MyStruct.to_string()")
        return ""
    }
}

EmptyStruct := struct {} // NOTE: empty struct instantiations are allowed
Vec2 := struct {
    mut x : I64 = 0
    mut y : I64 = 0

    add_all_coordinates := func(self: Vec2) returns I64 {
        return add(self.x, self.y)
    }
}

Vec3 := struct {
    mut x : I64 = 0
    mut y : I64 = 0
    mut z : I64 = 0
}

// my_struct_type := MyStruct
// trying_dot_struct2 : Bool = MyStruct.bool_field.ccccc // TODO implement nested structs

test_structs := proc() {
    test(MyStruct.static_bool_field, "MyStruct.static_bool_field is not true")
    my_empty_struct := EmptyStruct() // NOTE: empty instantiations are allowed
    mut my_vec2 := Vec2()
    my_vec2.x = 40
    my_vec2.y =  2
    assert_eq(42, Vec2.add_all_coordinates(my_vec2)) // associated functions using fields
    assert_eq(42, my_vec2.add_all_coordinates()) // associated functions can be used as methods (if the first argument matches the type)
    mut my_vec3 := Vec3()
    my_vec3.z = 42
    assert_eq(42, my_vec3.z) // access to struct fields as arguments

    my_struct := MyStruct.new(true, 42, "my field string") // TODO Fix custom constructor
    // assert(my_struct.bool_field) // TODO Fix
    // assert_eq(42, my_struct.int_field) // TODO Fix
    // assert_eq_str("my field string", my_struct.string_field) // TODO Fix

    // my_bool := Bool() // TODO allow instantiations of core types
    // my_i64 := I64() // TODO truly self host I64 with an [8]U8
    // my_string := String() // TODO don't migrate from string to String, just self host it after structs and pointers

}
test_structs()
