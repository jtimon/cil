mode lib

not := ext_func(a: bool) returns bool;
// and := ext_func(a: bool) returns bool; // TODO variadic args
// or  := ext_func(a: bool) returns bool; // TODO variadic args

eq := ext_func(a: i64, b: i64) returns bool;
lt := ext_func(a: i64, b: i64) returns bool;
lteq := ext_func(a: i64, b: i64) returns bool;
gt := ext_func(a: i64, b: i64) returns bool;
gteq := ext_func(a: i64, b: i64) returns bool;
str_eq := ext_func(a: String, b: String) returns bool;

add := ext_func(a: i64, b: i64) returns i64;
sub := ext_func(a: i64, b: i64) returns i64;
mul := ext_func(a: i64, b: i64) returns i64;
div := ext_func(a: i64, b: i64) returns i64;

btoa := ext_func(a: bool) returns String;
itoa := ext_func(a: i64) returns String;

exit := ext_proc(code: i64);
import := ext_proc(path: String);
runfile := ext_proc(path: String);
// print   := ext_proc(); // TODO variadic args
// println := ext_proc(); // TODO variadic args

eval_to_str := ext_proc(a: String) returns String;
input_read_line := ext_proc(a: String) returns String;

// fails because mut func/procs shouldn't be allowed at this context level, in this mode, or perhaps never
// mut assertm := proc(cond: bool, msg: String) {
assertm := proc(cond: bool, msg: String) {
    if not(cond) {
        println("assert failed: ", msg)
        exit(1)
    }
}

assert := proc(cond: bool) {
    assertm(cond, "")
}

test := proc(cond: bool, msg: String) {
    assertm(cond, msg)
}

// TODO use assert_eq_str in some example
assert_eq_str := proc(a: String, b: String) {
    if not(str_eq(a, b)) {
        println("assert_eq_str failed: '", a, "' != '", b, "'")
        exit(1)
    }
}

panic := proc(msg: String) {
    assertm(false, msg)
}
// panic("panic panics when uncommented") // fails, because it panics

todo := proc(msg: String) {
    print("TODO: ")
    assertm(false, msg)
}

branchless := func(cond: bool, a: i64, b: i64) returns i64 {
    return add(mul(a, Bool.to_int(cond)), mul(b, Bool.to_int(not(cond))))
}

Bool := struct {

    to_str := func(b: bool) returns String {
        return btoa(b)
    }

    // TODO Use in branchless
    to_int := func(data: bool) returns i64 {
        return btoi(data)
    }
}

Int := struct {
    to_str := func(data: i64) returns String {
        return itoa(data)
    }
}

I64 := struct {
     to_str := func(i: i64) returns String {
          return itoa(i)
     }
}

// TODO fix aliases
// my_int : U64 = 1

// Note aliases can be used before declared:
// Bool : Type = bool
// Integer : Type = i64
// Unsigned : Type = i64
// U64 : Type = i64
// OtherType : Type = Type

# I64 := struct {
#     mut data : i64 = 0

#     // init := func(i: i64) returns I64 {
#     //     n : I64
#     // 	n.data = i;
#     // 	return n
#     // }

#     // _add := func(self: I64, other: I64) returns I64 {
#     // 	return add(self.data, other.data)
#     // }

#     // to_string := func(self: I64) returns String {
#     // 	return itoa(self.data)
#     // }
# }
