zero := false
one := or(zero, true)
aaa := and(false, false, false, true, false)
bbb := or(false, true, false)
// and := true // fails, double declaration
// aaa := true // fails, double declaration

my_func := func(a: bool, b: bool) returns bool {
//     println(a, b) // fails, funcs cannot call procs
    return and(a, b)
}

res := my_func(true, true)
my_func(true, my_func(true, my_func(true, true)))
and(res, my_func(true, my_func(true, true)))
my_func(res, my_func(true, my_func(true, true)))

my_proc := proc(a: bool, b: bool) {
    println("inside my_proc, two bools: ", a, ", ", b)
}

my_num0 := 1
my_string := "aaaaa"

xor := func(a: bool, b: bool) returns bool {
    return or(and(not(a), b), and(a, not(b)))
}

main := proc() {
     println("printed with println core proc: ", "aaaaa ", 42, " ",  true, " aaaaa")
     println("xor(true, false) == ", xor(true, false))
     println(and(true, true), or(true, false), not(false), xor(false, true))
     println(eq(2, 2), lt(1, 2), lteq(2, 2), gt(3, 2), gteq(2, 2))
     println(add(40, 2), " ", sub(44, 2), " ", mul(6, 7), " ", div(420, 10))

     my_proc(false, true)
}
main()

// TODO next:

// mut my_num := 1
// my_num = 2

// my_list := (true, 1111, "hello")

// myproc := proc(a, b) returns bool {
//     return print(myfunc(a, b))
// }

// my_num := 1111
// and(true, my_num) // fails, and cannot take number literals

// my_str := "asdfgdfafgd"
// and(true, my_str) // fails, and cannot take string literals

// FIX literals have to work in the repl
// "aaa"
// 1111
// true
// false


// TODO should error on comptime
// and("aaa" or(true) true)


// (true (true 1111 "1a" aaa) (false 2222 "2b" bbb))

// TODO runtime: 'and' only takes bool
// add(1, true, true)

// TODO runtime and only takes bool
// add("1", true, true)

// println(true, or(false, true), true)

// test(true, true, "true should be true")

// test_assert(true, true, "true should be true");
// test_assert(true, not(false), "true should not be false");
// test_err(print(true), "Procedure 'print' can't be used as primary expression.");
