// mode rust

// intro to the language:

// adsgffdgfdg sdfgfsdgsf @ sdfhgsfgh dfghj dgfhj // fails because @ is invalid on the lexer
AAA : bool = and(false, false, false, true, false) // Explicit types are allowed in declarations, but optional
BBB := or(false, true, false) // It is a strongly typed language, but allows type inference (not in arguments yet, never in return types)
// and := true // fails, double declaration of core func 'and'
// AAA := true // fails, double declaration of user constant 'AAA'
// AAA = false // fails, assignment to a constant, all declarations are constant by default

// There can also be pure functions
my_func := func(a: bool, b: bool) returns bool {
//     println("proc") // fails, funcs cannot call procs
    return and(a, b)
}
test(my_func(true, true), "my_func(true, true) didn't return true")

// procedures can be declared and called
example_basic_workflow := proc() {

    mut it := 0 // one has to use the 'mut' keyword for actual variables, since all declarations are const by default
    print("it: ")
    // while 42 { // fails, because while expects a bool first, not an int
    while lt(it, 10) {
        print(itoa(it), " ")
        it = add(it, 1)
    }
    println(" ")

    // and(true, 1111) // fails, and cannot take number literals
    // and(true, "asdfgdfafgd") // fails, and cannot take string literals

    // if 42 { // fails, because if expects a bool first, not an int
    if gteq(4, 2) {
        println("aaaaaaaa")
    } else {
        println("bbbbbbbb")
    }

    abc := proc(a: bool, b: bool, c: bool) {
	println("inside abc, three bools: ", btoa(a), ", ", btoa(b), ", ", btoa(c))
    }
    abc(true, true, true)
}
example_basic_workflow()

// self hosted:

assertm := proc(cond: bool, msg: String) {
    if not(cond) {
        println("assert failed: ", msg)
        exit(1)
    }
}

assert := proc(cond: bool) {
    assertm(cond, "")
}

test := proc(cond: bool, msg: String) {
    assertm(cond, msg)
}

panic := proc(msg: String) {
    assertm(false, msg)
}
// panic("panic panics when uncommented") // fails, because it panics

// self hosted tests/examples:

// logic 101:
test(true, "true is true")
test(not(false), "not: not false is true")
test(not(not(true)), "not: not not true is true")
test(eq(btoi(false), btoi(not(true))), "false is not true")
test(not(or(false, false)), "or: two false don't make a true")
test(and(true, true), "and: true and true is true")
test(or(true, false), "and: true or false is true")
test(eq(btoi(not(true)), btoi(false)), "not true is false")
test(eq(btoi(eq(2, 2)), btoi(true)), "2 and 2 are equal")

// comparisons 101:
test(eq(0, 0), "0 == 0")
test(eq(2, 2), "2 == 2")
test(lt(0, 1), "0 is less than 1")
test(gt(2, 1), "2 is greater than 1")
test(lteq(2, 2), "2 is gt-equal to 2")
test(gteq(2, 2), "2 is lt-equal to 2")

// arithmetics 101:
test(eq(add(2, 2), 4), "2 + 2 = 4")
test(eq(mul(2, 2), 4), "2 * 2 = 4")
// TODO exp: test(eq(exp(2, 2), 4), "2 ** 2 == 4")

// arithmetics 42:
test(eq(add(40, 2), 42), "40 + 2 = 42")
test(eq(sub(44, 2), 42), "44 - 2 = 42")
test(eq(mul(6, 7), 42), " 6 * 7 = 42")
test(eq(div(420, 10), 42), " 420 / 10 = 42")

// branchless conditions

branchless := func(cond: bool, a: i64, b: i64) returns i64 {
    return add(mul(a, btoi(cond)), mul(b, btoi(not(cond))))
}

test(eq(4, branchless(true, 4, 2)), " branchless(true, 4, 2) = 4")
test(eq(2, branchless(false, 4, 2)), " branchless(true, 4, 2) = 2")

// Here are some examples of pure functions, this time with recursion:
fib_test := proc(fib_arg: i64) {
    fibonacci := func(n: i64) returns i64 {
        if lt(n, 2) {
            return n
        }
        return add(fibonacci(sub(n, 1)), fibonacci(sub(n, 2)))
    }

    fibonacci2 := func(n: i64) returns i64 {
        if lt(n, 2) {
            return n
        } else {
            return add(fibonacci2(sub(n, 1)), fibonacci2(sub(n, 2)))
	}
    }

    println("fibonacci: of ", itoa(fib_arg), " = ", itoa(fibonacci(fib_arg)))
    println("fibonacci2: of ", itoa(fib_arg), " = ", itoa(fibonacci2(fib_arg)))
}
fib_test(15)
// fibonacci(15) // fails because 'fibonacci' is defined locally inside fib_test

main := proc() {
    // Note that xor is defined after main but used inside it
    println("printed from main: xor(true, false) == ", btoa(xor(true, false)))

    my_bool := true
    my_num1 := 1
    my_string := "aaaa "

    my_func(my_bool, my_func(true, my_func(true, true)))
    res := my_func(true, true) // TODO fix type inference
    and(res, my_func(true, my_func(true, true)))
    my_func(res, my_func(true, my_func(true, true)))

    println("printed from main: ", my_string, itoa(42), " ", btoa(true), " bbbbb")

    // abc(false, true, false) // fails, because abc is defined locally in proc example_basic_workflow
}
main()

////////////////
// TODO mut func/procs shouldn't be allowed at this level, in this mode
// mut xor := func(a: bool, b: bool) returns bool {
xor := func(a: bool, b: bool) returns bool {
    return or(and(not(a), b), and(a, not(b)))
}

// TODO fix col for invalid args
// and(true, false, true, 15, "aaa", true, false) // fails because and only takes bool args

ExampleEnum := enum {
    eA
    eB
    LBool : bool
    LNumber : i64
    LString : String
    eC
    eD
}

MyStruct := struct {
    bool_field : bool = false
    int_field : i64 = 0
    string_field := ""
    bool_method_func := func() returns bool {
        return true
    }
    bool_method_proc := proc() returns bool {
	print("bool_method_proc called")
	return false
    }
}

// trying_dot : bool = MyStruct.bool_field.ccccc.dddddd.eeeee.ffffff

// TODO next:

ExampleEnum2 := enum {
    // AAA : AAA // TODO This fails, because AAA is not a type, it's a bool
    // BBB : MyStruct // TODO This fails, because custom types are not allowed yet in enums
    // CCC : CCC // TODO This fails, because CCC is not defined
    DDD
}

exit(0)

// my_bool_array := [true, false, true, false]
// my_bool_array : [4]bool = [true, false, true, false]
// my_list := (true, 1111, "hello")

// test_enums := proc() {
//     enum_to_switch := ExampleEnum2.BBB
//     switch enum_to_switch {
//         ExampleEnum2.BBB {
//             println("bbbbbb")
// 	}
//         ExampleEnum2.DDD {
//             println("dddddd")
// 	}
//     }
// }
// test_enums()

// test_structs := proc() {
//     if MyStruct.bool_field {
//         println("aaaaaaaa")
//     }
// }
// test_structs()

// test_int_switch := proc (i64_to_switch: i64) returns String {
//     if eq(42, i64_to_switch) {
//        return "That's the answer."
//     } else {
//        return "test_int_switch is not implemented yet."
//     }
// }
// println(test_int_switch(42))
// println(test_int_switch(43))

// FIX literals have to work in the repl
// "aaa"
// 1111
// true
// (true (true 1111 "1a" aaa) (false 2222 "2b" bbb))
