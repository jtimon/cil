// mode script

AAA : bool = and(false, false, false, true, false) // Explicit types are allowed in declarations, but optional
BBB := or(false, true, false) // It is a strongly typed language, but allows type inference (not in arguments yet, never in return types)
// and := true // fails, double declaration of core func 'and'
// AAA := true // fails, double declaration of user constant 'AAA'
// AAA = false // fails, assignment to a constant, all declarations are constant by default

// There can also be pure functions
my_func := func(a: bool, b: bool) returns bool {
//     println(btoa(a), btoa(b)) // fails, funcs cannot call procs
    return and(a, b)
}
my_func(true, true)

// procedures can be declared and called
example_basic_workflow := proc() {

    // TODO fix type inference
    mut it : i64 = 0 // one has to use the 'mut' keyword for actual variables, since all declarations are const by default
    print("it: ")
    while lt(it, 10) {
        print(itoa(it), " ")
        it = add(it, 1)
    }
    println(" ")

    if gteq(4, 2) {
        println("aaaaaaaa")
    } else {
        println("bbbbbbbb")
    }

    abc := proc(a: bool, b: bool, c: bool) {
	println("inside abc, three bools: ", btoa(a), ", ", btoa(b), ", ", btoa(c))
    }
    abc(true, true, true)
}
example_basic_workflow()

// Here are some examples of pure functions, this time with recursion:
fib_test := proc(fib_arg: i64) {
    fibonacci := func(n: i64) returns i64 {
        if lt(n, 2) {
            return n
        }
        return add(fibonacci(sub(n, 1)), fibonacci(sub(n, 2)))
    }

    fibonacci2 := func(n: i64) returns i64 {
        if lt(n, 2) {
            return n
        } else {
            return add(fibonacci2(sub(n, 1)), fibonacci2(sub(n, 2)))
	}
    }

    println("fibonacci: of ", itoa(fib_arg), " = ", itoa(fibonacci(fib_arg)))
    println("fibonacci2: of ", itoa(fib_arg), " = ", itoa(fibonacci2(fib_arg)))
}
fib_test(15)

main := proc() {
    my_bool := true
    my_num1 := 1
    my_string := "aaaa"

    my_func(true, my_func(true, my_func(true, true)))
    // res := my_func(true, true) // TODO fix type inference
    res : bool = my_func(true, true)
    and(res, my_func(true, my_func(true, true)))
    my_func(res, my_func(true, my_func(true, true)))

    println("printed with println core proc: ", "aaaaa ", itoa(42), " ", btoa(true), " bbbbb")
    println("xor(true, false) == ", btoa(xor(true, false))) // Note that xor is defined after main but used inside it
    println(btoa(and(true, true)), btoa(or(true, false)), btoa(not(false)), btoa(xor(false, true)))
    println(btoa(eq(2, 2)), btoa(lt(1, 2)), btoa(lteq(2, 2)), btoa(gt(3, 2)), btoa(gteq(2, 2)))
    println("bin basic i64 ops: ", itoa(add(40, 2)), " ", itoa(sub(44, 2)), " ", itoa(mul(6, 7)), " ", itoa(div(420, 10)))

    // abc(false, true, false) // fails, because abc is defined locally in proc example_basic_workflow
}
main()

xor := func(a: bool, b: bool) returns bool {
    return or(and(not(a), b), and(a, not(b)))
}

// TODO FIX handle col properly, @ should fail
// adsgffdgfdg sdfgfsdgsf @ sdfhgsfgh dfghj dgfhj // fails because @ is invalid on the lexer
// and(true, false, true, 15, "aaa", true, false) // fails because it only takes bool args

// TODO next:

// my_bool_slice : []bool = [true, false, true, false]
// my_list := (true, 1111, "hello")

// my_struct := struct {
//     bool_field := false
//     int_field := 0
//     string_field := ""
//     bool_method_func := func() returns bool {
//         return true
//     }
//     bool_method_proc := proc() returns bool {
// 	print("bool_method_proc called")
// 	return false
//     }
// }

// NodeType := enum {
//     LBool
//     LNumber
//     LString
// }

//// TODO mode test

// my_num := 1111
// and(true, my_num) // fails, and cannot take number literals

// my_str := "asdfgdfafgd"
// and(true, my_str) // fails, and cannot take string literals

// FIX literals have to work in the repl
// "aaa"
// 1111
// true
// (true (true 1111 "1a" aaa) (false 2222 "2b" bbb))

// test(true, true, "true should be true")

// test_assert(true, true, "true should be true");
// test_assert(true, not(false), "true should not be false");
// test_err(print(true), "Procedure 'print' can't be used as primary expression.");
