// mode script

// adsgffdgfdg sdfgfsdgsf @ sdfhgsfgh dfghj dgfhj // fails because @ is invalid on the lexer
AAA : bool = and(false, false, false, true, false) // Explicit types are allowed in declarations, but optional
BBB := or(false, true, false) // It is a strongly typed language, but allows type inference (not in arguments yet, never in return types)
// and := true // fails, double declaration of core func 'and'
// AAA := true // fails, double declaration of user constant 'AAA'
// AAA = false // fails, assignment to a constant, all declarations are constant by default

// There can also be pure functions
my_func := func(a: bool, b: bool) returns bool {
//     println(btoa(a), btoa(b)) // fails, funcs cannot call procs
    return and(a, b)
}
my_func(true, true)

// procedures can be declared and called
example_basic_workflow := proc() {

    mut it := 0 // one has to use the 'mut' keyword for actual variables, since all declarations are const by default
    print("it: ")
    // while 42 { // fails, because while expects a bool first, not an int
    while lt(it, 10) {
        print(itoa(it), " ")
        it = add(it, 1)
    }
    println(" ")

    // and(true, 1111) // fails, and cannot take number literals
    // and(true, "asdfgdfafgd") // fails, and cannot take string literals

    // if 42 { // fails, because if expects a bool first, not an int
    if gteq(4, 2) {
        println("aaaaaaaa")
    } else {
        println("bbbbbbbb")
    }

    abc := proc(a: bool, b: bool, c: bool) {
	println("inside abc, three bools: ", btoa(a), ", ", btoa(b), ", ", btoa(c))
    }
    abc(true, true, true)
}
example_basic_workflow()

// Here are some examples of pure functions, this time with recursion:
fib_test := proc(fib_arg: i64) {
    fibonacci := func(n: i64) returns i64 {
        if lt(n, 2) {
            return n
        }
        return add(fibonacci(sub(n, 1)), fibonacci(sub(n, 2)))
    }

    fibonacci2 := func(n: i64) returns i64 {
        if lt(n, 2) {
            return n
        } else {
            return add(fibonacci2(sub(n, 1)), fibonacci2(sub(n, 2)))
	}
    }

    println("fibonacci: of ", itoa(fib_arg), " = ", itoa(fibonacci(fib_arg)))
    println("fibonacci2: of ", itoa(fib_arg), " = ", itoa(fibonacci2(fib_arg)))
}
fib_test(15)

main := proc() {
    // Note that xor is defined after main but used inside it
    println("printed from main: xor(true, false) == ", btoa(xor(true, false)))

    my_bool := true
    my_num1 := 1
    my_string := "aaaa "

    my_func(my_bool, my_func(true, my_func(true, true)))
    res := my_func(true, true) // TODO fix type inference
    and(res, my_func(true, my_func(true, true)))
    my_func(res, my_func(true, my_func(true, true)))

    println("printed from main: ", my_string, itoa(42), " ", btoa(true), " bbbbb")
    println(btoa(and(true, true)), btoa(or(true, false)), btoa(not(false)), btoa(xor(false, true)))
    println(btoa(eq(2, 2)), btoa(lt(my_num1, 2)), btoa(lteq(2, 2)), btoa(gt(3, 2)), btoa(gteq(2, 2)))
    println("bin basic i64 ops: ", itoa(add(40, 2)), " ", itoa(sub(44, 2)), " ", itoa(mul(6, 7)), " ", itoa(div(420, 10)))

    // abc(false, true, false) // fails, because abc is defined locally in proc example_basic_workflow
}
main()

// TODO mut func/procs shouldn't be allowed at this level, in this mode
// mut xor := func(a: bool, b: bool) returns bool {
xor := func(a: bool, b: bool) returns bool {
    return or(and(not(a), b), and(a, not(b)))
}

branchless := func(cond: bool, a: i64, b: i64) returns i64 {
    return add(mul(a, btoi(cond)), mul(b, btoi(not(cond))))
}

println("testing branchless: should be 4 = ", itoa(branchless(true, 4, 2)))
println("testing branchless: should be 2 = ", itoa(branchless(false, 4, 2)))

// TODO fix col for invalid args
// and(true, false, true, 15, "aaa", true, false) // fails because and only takes bool args

ExampleEnum := enum {
    eA
    eB
    LBool : bool
    LNumber : i64
    LString : String
    eC
    eD
}

MyStruct := struct {
    bool_field : bool = true
    int_field : i64 = 0
    string_field := ""
    bool_method_func := func() returns bool {
        return true
    }
    bool_method_proc := proc() returns bool {
	print("bool_method_proc called")
	return false
    }
}

// TODO next:

ExampleEnum2 := enum {
//     AAA : AAA // TODO should fail, because AAA is not a type, it's a bool
    BBB
//     CCC : CCC // TODO should fail, because CCC is not defined
    DDD
}
// trying_dot := __a.b

exit(0)

// test_enums := proc() {
//     enum_to_switch := ExampleEnum2.BBB
//     switch enum_to_switch {
//         ExampleEnum2.BBB {
//             println("bbbbbb")
// 	}
//         ExampleEnum2.DDD {
//             println("dddddd")
// 	}
//     }
// }
// test_enums()

// test_structs := proc() {
//     if MyStruct.bool_field {
//         println("aaaaaaaa")
//     }
// }
// test_structs()

// my_bool_slice : []bool = [true, false, true, false]
// my_list := (true, 1111, "hello")

// test_int_switch := proc (i64_to_switch: i64) returns String {
//     if eq(42, i64_to_switch) {
//        return "That's the answer."
//     } else {
//        return "test_int_switch is not implemented yet."
//     }
// }
// println(test_int_switch(42))
// println(test_int_switch(43))

//// TODO mode test

// FIX literals have to work in the repl
// "aaa"
// 1111
// true
// (true (true 1111 "1a" aaa) (false 2222 "2b" bbb))

// test(true, true, "true should be true")

// test_assert(true, true, "true should be true");
// test_assert(true, not(false), "true should not be false");
// test_err(print(true), "Procedure 'print' can't be used as primary expression.");
