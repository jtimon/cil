// mode pura

AAA := and(false, false, false, true, false)
BBB := or(false, true, false)
// and := true // fails, double declaration of core func 'and'
// AAA := true // fails, double declaration of user constant 'AAA'

xor := func(a: bool, b: bool) returns bool {
    return or(and(not(a), b), and(a, not(b)))
}

my_func := func(a: bool, b: bool) returns bool {
//     println(btoa(a), btoa(b)) // fails, funcs cannot call procs
    return and(a, b)
}

my_proc := proc(a: bool, b: bool) {
    println("inside my_proc, two bools: ", btoa(a), ", ", btoa(b))
}

main := proc() {
    my_bool := true
    my_num1 := 1
    my_string := "aaaa"

    res := my_func(true, true)
    my_func(true, my_func(true, my_func(true, true)))
    and(res, my_func(true, my_func(true, true)))
    my_func(res, my_func(true, my_func(true, true)))

    println("printed with println core proc: ", "aaaaa ", itoa(42), " ", btoa(true), " bbbbb")
    println("xor(true, false) == ", btoa(xor(true, false)))
    println(btoa(and(true, true)), btoa(or(true, false)), btoa(not(false)), btoa(xor(false, true)))
    println(btoa(eq(2, 2)), btoa(lt(1, 2)), btoa(lteq(2, 2)), btoa(gt(3, 2)), btoa(gteq(2, 2)))
    println(itoa(add(40, 2)), " ", itoa(sub(44, 2)), " ", itoa(mul(6, 7)), " ", itoa(div(420, 10)))

    my_proc(false, true)
}
main()

if lt(4, 5) {
    println("aaaaaaaa")
} else {
    println("bbbbbbbb")
}

int_func := proc(a: i64, b: i64) returns i64 {
    if lt(a, b) {
        return add(a, b)
    }
    return sub(a, b)
}

int_func2 := proc(a: i64, b: i64) returns i64 {
    if lt(a, b) {
        return add(a, b)
    } else {
        return sub(a, b)
    }
}

println("int_func result: ", itoa(int_func(36, 35)))
println("int_func2 result: ", itoa(int_func2(36, 35)))

fibonacci := func(n: i64) returns i64 {
    if lt(n, 2) {
        return n
    }
    return add(fibonacci(sub(n, 1)), fibonacci(sub(n, 2)))
}

fibonacci2 := func(n: i64) returns i64 {
    if lt(n, 2) {
        return n
    } else {
        return add(fibonacci2(sub(n, 1)), fibonacci2(sub(n, 2)))
    }
}

fib_arg := 15
println("fibonacci of ", itoa(fib_arg), " = ", itoa(fibonacci(fib_arg)))
println("fibonacci2 of ", itoa(fib_arg), " = ", itoa(fibonacci2(fib_arg)))

// TODO FIX handle col properly, @ should fail
// adsgffdgfdg sdfgfsdgsf @ sdfhgsfgh dfghj dgfhj // fails because @ is invalid on the lexer
// and(true, false, true, 15, "aaa", true, false) // fails because it only takes bool args

// TODO next:

it := 2
// it = 1

// while lt(it, 10) {
//     print(itoa(it), " ")
//     it = add(it, 1)
// }
// printl(" ")

// my_struct := struct {
//     bool_field := false
//     int_field := 0
//     string_field := ""
//     bool_method_func := func() returns bool {
//         return true
//     }
//     bool_method_proc := proc() returns bool {
// 	print("bool_method_proc called")
// 	return false
//     }
// }

// NodeType := enum {
//     LBool
//     LNumber
//     LString
// }

// my_bool_slice : []bool = [true, false, true, false]
// my_list := (true, 1111, "hello")

//// TODO mode test

// my_num := 1111
// and(true, my_num) // fails, and cannot take number literals

// my_str := "asdfgdfafgd"
// and(true, my_str) // fails, and cannot take string literals

// FIX literals have to work in the repl
// "aaa"
// 1111
// true
// (true (true 1111 "1a" aaa) (false 2222 "2b" bbb))

// test(true, true, "true should be true")

// test_assert(true, true, "true should be true");
// test_assert(true, not(false), "true should not be false");
// test_err(print(true), "Procedure 'print' can't be used as primary expression.");
