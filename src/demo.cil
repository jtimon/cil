// TODO implement other modes: script, safe_script, main, pure, proc, etc
mode test

//// Intro to the language
// @ // fails because @ is invalid on the lexer for now

// Declarations and assignments:

// adsgffdgfdg sdfgfsdgsf @ dfghj dgfhj // fails because @ is invalid on the lexer
AAA : bool = and(false, false, false, true, false) // Explicit types are allowed in declarations, but optional
BBB := or(false, true, false) // It is a strongly typed language, but allows type inference (not in arguments yet, never in return types)
// AAA := true // fails, re-declaration of user constant 'AAA'
// AAA = false // fails, assignment to a constant, all declarations are constant by default

// core bool functions used as examples:

// and := true // fails, re-declaration of core func 'and'
// or := true // fails, re-declaration of core func 'or'
// not := func(a: bool) returns bool {} // fails, re-declaration of core func 'not'

// Pure functions:

my_func := func(a: bool, b: bool) returns bool {
//     println("proc") // fails, funcs cannot call procs
    return and(a, b)
}
test(my_func(true, true), "my_func(true, true) didn't return true")

// procedures can be declared and directly called in some modes
example_basic_workflow := proc() {

    mut it := 0 // one has to use the 'mut' keyword for actual variables, since all declarations are const by default
    print("it: ")
    // while 42 { // fails, because while expects a bool first, not an int
    while lt(it, 10) {
        print(itoa(it), " ")
        it = add(it, 1)
    }
    println(" ")

    // and(true, 1111) // fails, and cannot take number literals
    // and(true, "asdfgdfafgd") // fails, and cannot take string literals

    // if 42 { // fails, because if expects a bool first, not an int
    if gteq(4, 2) {
        println("aaa", "y", "aaa")
        print("aaa", "y", "eee")
        print("\n") // TODO make this and the next line be equivalent
        println("")
    } else {
        println("bbbbbbbb")
    }

    abc := proc(a: bool, b: bool, c: bool) {
	println("inside abc, three bools: ", btoa(a), ", ", btoa(b), ", ", btoa(c))
    }
    abc(true, true, true)
}
example_basic_workflow()

// self hosted:

// TODO mut func/procs shouldn't be allowed at this level, in this mode, or perhaps never
mut assertm := proc(cond: bool, msg: String) {
// assertm := proc(cond: bool, msg: String) {
    if not(cond) {
        println("assert failed: ", msg)
        exit(1)
    }
}

assert := proc(cond: bool) {
    assertm(cond, "")
}

test := proc(cond: bool, msg: String) {
    assertm(cond, msg)
}

panic := proc(msg: String) {
    assertm(false, msg)
}
// panic("panic panics when uncommented") // fails, because it panics

// self hosted tests/examples:

// logic 101:
test(true, "true is true")
test(not(false), "not: not false is true")
test(not(not(true)), "not: not not true is true")
test(eq(btoi(false), btoi(not(true))), "false is not true")
test(not(or(false, false)), "or: two false don't make a true")
test(and(true, true), "and: true and true is true")
test(or(true, false), "and: true or false is true")
test(xor(true, false), "and: true xor false is true") // Note that xor is used before being defined, but in the same file context
test(eq(btoi(not(true)), btoi(false)), "not true is false")
test(eq(btoi(eq(2, 2)), btoi(true)), "2 and 2 are equal")

// TODO mut func/procs shouldn't be allowed at this level, in this mode, or perhaps never
xor := func(a: bool, b: bool) returns bool {
    return or(and(not(a), b), and(a, not(b)))
}

// comparisons 101:
test(eq(0, 0), "0 == 0")
test(eq(2, 2), "2 == 2")
test(lt(0, 1), "0 is less than 1")
test(gt(2, 1), "2 is greater than 1")
test(lteq(2, 2), "2 is gt-equal to 2")
test(gteq(2, 2), "2 is lt-equal to 2")

// arithmetics 101:
test(eq(add(2, 2), 4), "2 + 2 = 4")
test(eq(mul(2, 2), 4), "2 * 2 = 4")
// TODO exp: test(eq(exp(2, 2), 4), "2 ** 2 == 4")

// arithmetics 42:
test(eq(add(40, 2), 42), "40 + 2 = 42")
test(eq(sub(44, 2), 42), "44 - 2 = 42")
test(eq(mul(6, 7), 42), " 6 * 7 = 42")
test(eq(div(420, 10), 42), " 420 / 10 = 42")

// branchless conditions

branchless := func(cond: bool, a: i64, b: i64) returns i64 {
    return add(mul(a, btoi(cond)), mul(b, btoi(not(cond))))
}

test(eq(4, branchless(true, 4, 2)), " branchless(true, 4, 2) = 4")
test(eq(2, branchless(false, 4, 2)), " branchless(true, 4, 2) = 2")

// Here are some examples of pure functions, this time with recursion:
fib_test := proc(fib_arg: i64) {
    fibonacci0 := func(n: i64) returns i64 {
        if lt(n, 2) {
            return n
        }
        return add(fibonacci0(sub(n, 1)), fibonacci0(sub(n, 2)))
    }

    fibonacci1 := func(n: i64) returns i64 {
        if lt(n, 2) {
            return n
        } else {
            return add(fibonacci1(sub(n, 1)), fibonacci1(sub(n, 2)))
	}
    }

    println("fibonacci: of ", itoa(fib_arg), " = ", itoa(fibonacci0(fib_arg)))
    println("fibonacci2: of ", itoa(fib_arg), " = ", itoa(fibonacci1(fib_arg)))
}
fib_test(15)
// fibonacci(15) // fails because 'fibonacci' is defined locally inside fib_test

my_str_func := func(a: String) returns String {
    return a
}
println(my_str_func("strings can be passed as params and returned"))

main := proc() {
    my_bool := true
    my_num1 := 1
    my_string := "aaaa "

    my_func(my_bool, my_func(true, my_func(true, true)))
    res := my_func(true, true) // TODO fix type inference
    and(res, my_func(true, my_func(true, true)))
    my_func(res, my_func(true, my_func(true, true)))

    // abc(false, true, false) // fails, because abc is defined locally in proc example_basic_workflow
}
main()

// TODO fix col for invalid args
// and(true, false, true, 15, "aaa", true, false) // fails because and only takes bool args

ExampleEnum := enum {
    A
    B
    C
}
// trying_dot_enum : ExampleEnum = 0 // fails because an enum is not an int
trying_dot_enum : ExampleEnum = ExampleEnum.A

my_enum_func := func(a: ExampleEnum) returns ExampleEnum {
    return a
}
my_enum_func(ExampleEnum.B)
trying_dot_enum2 : ExampleEnum = my_enum_func(ExampleEnum.B)
trying_dot_enum3 : ExampleEnum = my_enum_func(trying_dot_enum)

test_int_switch := proc (to_switch: i64) {
    switch to_switch {
    case add(40, 2):
       println("in test_int_switch(): ", itoa(to_switch), " is the answer.")
    case:
       println("in test_int_switch(): ", itoa(to_switch), " is a wrong answer.")
    }
}
test_int_switch(42)
test_int_switch(43)

// TODO fix assignments inside switch statements
test_switch_enum := proc(to_switch: ExampleEnum) returns String {
    mut to_return := ""
    switch to_switch {
        case ExampleEnum.A: to_return = "enum switch aaaaaa"
        case ExampleEnum.B: to_return = "enum switch bbbbbb"
        case: to_return = "enum cccccc by default"
    }
    // TODO core efine etoa, base_enum_to_str or some equivalent
    // println("in test_switch_enum: to_switch: ", etoa(to_switch), " to_return: ", to_return)

    println("inside test_switch_enum(): to_return: ", to_return)
    return to_return
}

println("test_switch_enum(A): ", test_switch_enum(ExampleEnum.A))
println("test_switch_enum(B): ", test_switch_enum(ExampleEnum.B))
// println("test_switch_enum(C): ", test_switch_enum(ExampleEnum.C))
// println("test_switch_enum(D): ", test_switch_enum(ExampleEnum.D))

// TODO fix macro() not implement yet
// test_return_switch_enum := macro(to_switch: ExampleEnum) returns String {}

// TODO fix returns inside switch statements
test_return_switch_enum := proc(to_switch: ExampleEnum) returns String {
    switch to_switch {
        case ExampleEnum.A: return "enum switch aaaaaa"
        case ExampleEnum.B: return "enum switch bbbbbb"
        case: return "enum cccccc by default"
    }
    return "xxxxxx because return inside switch doesn't work even for enum"
}
println("test_return_switch_enum(A): ", test_return_switch_enum(ExampleEnum.A))
println("test_return_switch_enum(B): ", test_return_switch_enum(ExampleEnum.B))
// println("test_return_switch_enum(C): ", test_return_switch_enum(ExampleEnum.C))
// println("test_return_switch_enum(D): ", test_return_switch_enum(ExampleEnum.D))

// TODO next:

// TODO undeclared custom arguments should fail at compile time
// test_fails_example := proc(example: Strng, msg: String) {
//   eval_example_result : String = _eval_string(example)
//   println(eval_example_result)
// }
// test_fails_example("enum_func_fails := func(a: ExampleEnumAAAAAAAA) returns ExampleEnum {}", "TODO implement test_fails_example() in the core")

MyStruct := struct {
    mut bool_field : bool = false
    mut int_field : i64 = 0
    mut string_field := ""

    int_const : i64 = 42
    // TODO forbid mut func/proc fields for now
    mut bool_method_func := func() returns bool {
        return true
    }
    bool_method_proc := proc() returns bool {
	print("bool_method_proc called")
	return false
    }
}

// my_struct := MyStruct()
// trying_dot_struct : bool = MyStruct.bool_field.ccccc

ExampleEnum2 := enum {
    // AAA : AAA // TODO This fails, because AAA is not a type, it's a bool
    // BBB : MyStruct // TODO This fails, because custom types are not allowed yet in enums
    // CCC : CCC // TODO This fails, because CCC is not defined
    DDD
    LBool : bool
    LNumber : i64
    LString : String
}

exit(0)

// my_bool_array := [true, false, true, false]
// my_bool_array : [4]bool = [true, false, true, false]
// my_list := (true, 1111, "hello")

// test_structs := proc() {
//     if MyStruct.bool_field {
//         println("aaaaaaaa")
//     }
// }
// test_structs()

// FIX literals have to work in the repl
// "aaa"
// 1111
// true
// (true (true 1111 "1a" aaa) (false 2222 "2b" bbb))
